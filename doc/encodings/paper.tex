\documentclass[a4paper]{article}
%\def\year{2020}\relax
%\usepackage{aaai20}  % DO NOT CHANGE THIS
\usepackage{times}  % DO NOT CHANGE THIS
\usepackage{helvet} % DO NOT CHANGE THIS
\usepackage{courier}  % DO NOT CHANGE THIS
\usepackage[hyphens]{url}  % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm}  % DO NOT CHANGE THIS
\frenchspacing  % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in}  % DO NOT CHANGE THIS
\setlength{\pdfpageheight}{11in}  % DO NOT CHANGE THIS

% our packages
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{bm}
\usepackage{booktabs}
%\usepackage[inline]{enumitem}
%\usepackage{mathtools}
%\usepackage{multirow}
%\usepackage[mode=buildnew,subpreambles=true]{standalone}
\usepackage{subcaption}
%\usepackage{todonotes}
\usepackage[table]{xcolor}  % TODO Comment out for final submission
%\usepackage{pgfplots}
%\usepackage{tikz}
\usepackage{natbib}


% Some useful macros
%\newcommand{\inlinecite}[1]{\citeauthor{#1}~(\citeyear{#1})}
%\newcommand{\citealp}[1]{\citeauthor{#1}~\citeyear{#1}}

\newcommand{\smallpar}[1]{{\vspace{10pt}\noindent \bf #1.}}

\newcommand{\free}[1]{\ensuremath{\mathrm{free}(#1)}}
\newcommand{\vars}{\ensuremath{\mathrm{vars}}}
\newcommand{\pre}{\ensuremath{\mathrm{pre}}}
\newcommand{\add}{\ensuremath{\mathrm{add}}}
\newcommand{\del}{\ensuremath{\mathrm{del}}}
\newcommand{\effs}{\ensuremath{\mathrm{effs}}}

\newcommand{\tup}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\tuple}[1]{\tup{#1}}  % Just an alias
\newcommand{\set}[1]{\ensuremath{\left\{#1 \right\}}}
\newcommand{\setst}[2]{\ensuremath{\left\{#1 \mid #2 \right\}}}

\newtheorem{definition}{Definition}
\newtheorem{definitionandtheorem}[definition]{Definition and Theorem}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{example}[definition]{Example}

\newcommand{\wip}[1]{{\color{red} #1}}  % From "work in progress" :-)
\newcommand{\gfm}[1]{\footnote{\color{red}{[Guillem] #1}}}

\newcommand{\numtasks}[1]{\small{(#1)}}

\newcommand{\badtx}{\ensuremath{\mathrm{BAD}}}

\setcounter{secnumdepth}{0} %May be changed to 1 or 2 if section numbers are desired.

%PDF Info Is REQUIRED.
% For /Author, add all authors within the parentheses, separated by commas. No accents or commands.
% For /Title, add Title in Mixed Case. No accents or commands. Retain the parentheses.
 \pdfinfo{
/Title ()
/Author ()
} %Leave this

\title{Representation Learning for Generalized Planning - SAT Encodings}
%Your title must be in mixed case, not sentence case.
% That means all verbs (including short verbs like be, is, using,and go),
% nouns, adverbs, adjectives should be capitalized, including both words in hyphenated terms, while
% articles, conjunctions, and prepositions are lower case unless they
% directly follow a colon or long dash
%\author{GFM}


\begin{document}

\maketitle

\section{Learning of Generalized Features \& Policy}

Encoding is parametrized by
\begin{itemize}
 \item Pool $F$ of description logic features $f$, each with given feature complexity $\mathcal{K}(f)$.
 \item Training set consisting of a sample of transitions from a number of instances of the same domain.
       At the moment we're assuming the sample is complete, and we have full information on whether each state
       in the sample is a goal state, an unsolvable state, or otherwise (see below for definitions). We also have access
       to the minimum distance to a goal $V^*(s)$ for each state $s$.
 \item A parameter $\delta$ which is a ``slack'' value to determine the maximum deviation from the optimal $V^*(s)$
 what we will allow in our policy. This will be made clearer in the encoding below.
\end{itemize}


\subsection{Terminology}
A state is called \emph{reachable} if there is a path to it from $s_0$, and
it is called \emph{solvable} if there is a path from it to a goal
state.
A state is \emph{alive} if it is solvable, reachable and not a
goal state~\cite{frances-et-al-ijcai2019}.

We use $T$ to denote the set of all transitions $(s, s')$ in the training sample such that $s$ is alive.

\subsection{Improvements}

\paragraph{Non-distinguishability of transitions as an equivalence relation.}
Any fixed, given pool of features $F$ implicitly defines an equivalence relation where to transitions are
equivalent iff they cannot be distinguished \emph{by any feature in $F$}.
If two transitions cannot be distinguished by any feature, then clearly either the policy computed by the SAT solver
considers all of them as ``good'', or as ``bad''.
We'll exploit this by using one single SAT variable to denote whether \emph{all transitions in a given equivalence
class} are good or bad. When exploiting this notion of equivalence (which is implemented as an optional feature of
the CNF generator), then every mention below to SAT variable $Good(s, s')$ needs to be read as $Good(s_{\star}, s_{\star}')$,
where $(s_{\star}, s_{\star}')$ is the \emph{representative} transition of the equivalence class to which $(s, s')$ belongs.

\paragraph{``Bad'' transitions.}
We use \badtx{} to denote the set of transitions that have been determined at preprocessing as necessarily
\emph{not} good.
At the moment, this set contains all transitions that go from an alive to an unsolvable state and, if using
equivalence relations, all those other transitions in whose equivalence class there is some other ``bad'' transition.


\paragraph{Feature dominance.}
Work In Progress.\footnote{This is implemented, but needs to be adapted to the equivalence classes improvement.}


\subsection{Variables}

\subsubsection{Main Variables}
\begin{itemize}
 \item $Good(s, s')$ for $s$ alive, $s'$ solvable and $(s, s') \not\in \badtx$.

 \item $V(s) \leq d$ for $s$ alive, and $d \in [0, D]$, where $D = \max_{s} \delta \cdot V^*(s)$.
 Note that for states $s$ that are a goal, we know $V(s)=0$, hence $V(s) \leq d$ for all $d$,
 and for states $s$ that are unsolvable, we know that $V(s) \not\leq d$ for all $d$.
 Thus, we can restrict SAT variables $V(s) \leq d$ to those states $s$ that are alive.

 \item $Select(f)$, for each feature $f$ in the feature pool.
\end{itemize}

\subsubsection{Auxiliary Variables}
\begin{itemize}
 \item We'll use $GV(s, s', d)$ to denote that $Good(s, s')$ and $V(s') \leq d$. This is enforced with the constraint
 $GV(s, s', d) \rightarrow Good(s, s') \land V(s') \leq d$ for $s, s'$ alive, $(s, s') \not\in \badtx$, $d \in [0, D)$.
 The other direction of the implication is not necessary.
\end{itemize}

\newpage

\subsection{Hard Constraints}

\smallpar{C1}
The policy has to be complete with respect to all alive states:
\begin{align}
\bigvee_{s' \text{ s.t. } (s, s') \in T \setminus \badtx} Good(s, s'),&\;\; \text{for $s$ alive.}
\end{align}


\smallpar{C2-3} Labeling a transition $(s, s')$ as ``good'' necessarily upper-bounds $V(s)$:
\begin{align}
 Good(s, s') \land V(s') \leq d \rightarrow V(s) \leq d+1,&\;\; \text{for $s, s'$ alive, $(s, s') \not\in \badtx$, $d \in [0, D)$.} \\
 Good(s, s') \rightarrow V(s) \leq d+1,&\;\; \text{for $s$ alive, $s'$ goal, $(s, s') \not\in \badtx$, $d \in [0, D)$.}
\end{align}

\smallpar{C3'} All transitions chosen as \emph{Good} need to have the same q-value:
\begin{align}
 V(s) \leq d+1 \land \neg V(s') \leq d \rightarrow \neg Good(s, s'),&\;\; \text{for $s, s'$ alive, $(s, s') \not\in \badtx$, $d \in [0, D)$.} \tag{\theequation${}^\prime$}
\end{align}


\smallpar{C4-5} Any upper bound on $V(s)$ (for $s$ not a goal) needs to be justified:
\begin{align}
 V(s) \leq d+1 \rightarrow \bigvee_{\substack{
 s' \text{ goal child of } s\\
 (s, s') \not\in \badtx}} Good(s, s') \lor
 \bigvee_{\substack{
 s' \text{ alive child of } s\\
 (s, s') \not\in \badtx}} GV(s, s', d),&
 \;\; \text{for $s$ alive, $d \in [0, D)$.} \\
 \neg V(s) \leq 0,&\;\; \text{for $s$ not a goal.}
\end{align}

\smallpar{C6}
At least one atom $V(s) \leq d$ is true for each alive state $s$:
\begin{align}
 \bigvee_{d \in [0, D]} V(s) \leq d,&\;\; \text{for $s$ alive.}
\end{align}

\smallpar{C7}
Atoms $V(s) \leq d$ are consistent among them:
\begin{align}
 V(s) \leq d \rightarrow V(s) \leq d+1,&\;\; \text{for $s$ alive, $d \in [0, D)$.}
\end{align}

\smallpar{C8-9}
Good transitions can be distinguished from bad transitions.
Let $(s, s')$ and $(t, t')$ be \emph{representative} transitions
of two different equivalence classes such that $(s, s') \not\in \badtx$
(which implies that $s'$ is solvable). Then,

\begin{align}
 Good(s, s') \rightarrow Good(t, t') \lor
 Dist(s, s', t, t'),&\;\; \text{for $s, t$ alive, $(t, t') \not\in \badtx$.} \\
 Good(s, s') \rightarrow
 Dist(s, s', t, t'),&\;\; \text{for $s, t$ alive, $(t, t') \in \badtx$.}
\end{align}

\noindent where $Dist(s, s', t, t')$ is shorthand for $\bigvee_{f \in D2(s, s', t, t')} Select(f)$.

\smallpar{C10}
$V(s)$ cannot be much larger than $V^+(s)$:
\begin{align}
 V(s) \leq \delta \cdot V^*(s),&\;\; \text{for $s$ alive.}
\end{align}

\subsection{Soft Constraints}
We simply post a constraint $\neg Select(f)$ for each feature $f$ in the pool, with weight equal to its complexity $\mathcal{K}(f)$.

\bibliographystyle{plain}
% Cross-referenced entries need to go after the entries that cross-reference them
\bibliography{abbrv-short,literatur,references,crossref-short}
\end{document}
